import { IQuantityDefinition } from "./DefinitionObject";
export declare class Quantity {
    private static PREFIXES;
    private static UNITS;
    private static BASE_UNITS;
    private static SIGNATURE_VECTOR;
    private static UNITY;
    private static UNITY_ARRAY;
    private static parsedUnitsCache;
    private static baseUnitCache;
    private static stringifiedUnitsCache;
    private conversionCache;
    private static PREFIX_VALUES;
    private static PREFIX_MAP;
    private static UNIT_VALUES;
    private static UNIT_MAP;
    private static OUTPUT_MAP;
    private static SIGN;
    private static INTEGER;
    private static SIGNED_INTEGER;
    private static FRACTION;
    private static FLOAT;
    private static EXPONENT;
    private static SCI_NUMBER;
    private static SIGNED_NUMBER;
    private static QTY_STRING;
    private static QTY_STRING_REGEX;
    private static POWER_OP;
    private static TOP_REGEX;
    private static BOTTOM_REGEX;
    private static BOUNDARY_REGEX;
    private static PREFIX_REGEX;
    private static UNIT_REGEX;
    private static UNIT_MATCH;
    private static UNIT_MATCH_REGEX;
    private static UNIT_TEST_REGEX;
    initValue: any;
    scalar: number;
    numerator: string[];
    denominator: string[];
    baseScalar: number;
    signature: number;
    private _isBase;
    private _units;
    static initialize(): void;
    constructor(initValue: string | number | IQuantityDefinition, initUnits?: string);
    clone(): Quantity;
    to(other: any): any;
    isCompatible(other: any): any;
    toBase(): any;
    isBase(): boolean;
    inverse(): Quantity;
    units(): string;
    isInverse(other: string | Quantity): any;
    isDegrees(): RegExpMatchArray;
    isTemperature(): RegExpMatchArray;
    isUnitless(): boolean;
    add(other: any): Quantity;
    sub(other: any): Quantity;
    mul(other: any): Quantity;
    div(other: any): Quantity;
    compareTo(other: any): any;
    eq(other: string | Quantity): boolean;
    lt(other: string | Quantity): boolean;
    lte(other: string | Quantity): boolean;
    gt(other: string | Quantity): boolean;
    gte(other: string | Quantity): boolean;
    same(other: Quantity): boolean;
    private parse(val);
    private static parseUnits(units);
    toBaseUnits(numerator: any, denominator: any): Quantity;
    private toTemp(src, dst);
    private toTempK(qty);
    private toDegrees(src, dst);
    private toDegK(qty);
    private subtractTemperatures(lhs, rhs);
    private subtractTempDegrees(temp, deg);
    private addTempDegrees(temp, deg);
    private getDegreeUnits(units);
    private updateBaseScalar();
    private unitSignature();
    private unitSignatureVector();
    private isString(value);
    private stringifyUnits(units);
    private simplify(units);
    private getOutputNames(units);
    cleanTerms(num: any, den: any): any[];
    private throwIncompatibleUnits();
}
